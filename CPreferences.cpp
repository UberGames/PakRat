/* 
	CPreferences.cpp

	Author:			Tom Naughton
	Description:	<describe the CPreferences class here>
*/

#include <LPreferencesFile.h>
#include <UDebugging.h>
#include "CTokenizer.h"
#include "CPreferences.h"
#include "AppConstants.h"
#include "utilities.h"


string quotedString(string inString)
{
	static string quote = " ";
	quote[0] = '"';
	return quote + inString + quote;
}

string colorToString(RGBColor color)
{
	char s[256];
	sprintf(s, "rgb %d %d %d", color.red, color.green, color.blue );
	return string(s);
}

RGBColor stringToColor(string color)
{
	string delimiters = string(",\t ");
	RGBColor outColor;
		
	CTokenizer tokenizer(color, delimiters);
	string token = tokenizer.nextToken();
	outColor.red = tokenizer.nextInt();
	outColor.green = tokenizer.nextInt();
	outColor.blue = tokenizer.nextInt();
	return outColor;
}

CPreferences::CPreferences()
{
	Handle preferencesHandle = nil;
	_preferencesFile = new LPreferencesFile((ConstStringPtr)"\pPakRat Prefs", (Boolean)kDontCreateFolder);
	_preferencesFileisWritable = false;			
	
	
	// load default preferences from resource
	preferencesHandle = ::GetResource('TEXT', TEXT_Preferences);
	::HLock(preferencesHandle);
	parsePreferences(preferencesHandle);
	::HUnlock(preferencesHandle);
	::ReleaseResource(preferencesHandle);
	
	
	
	// overlay users preferences
	
	// see if file exists
	FInfo fndrInfo;
	FSSpec	outFileSpec;
	_preferencesFile->GetSpecifier(outFileSpec);
	OSErr err = FSpGetFInfo(&outFileSpec, &fndrInfo);
		  
	if (!err) {
	
		_preferencesFile->OpenDataFork(fsRdWrPerm);
		_preferencesFileisWritable = true;			
		preferencesHandle = _preferencesFile->ReadDataFork();
		_preferencesFile->CloseDataFork();
		
		parsePreferences(preferencesHandle);
		::DisposeHandle(preferencesHandle);
		
	} else {
	

		try {
			dprintf("creating new preferences file\n");
			_preferencesFile->CreateNewDataFile(kApplicationCreator,'pref',smSystemScript);	
			_preferencesFileisWritable = true;	
					
		} catch (...) {
		
		}
	}

/*	this code is cranky today

	// overlay users preferences
	try {
	
		StDisableDebugThrow_(); // don't throw
				
		
		_preferencesFile->OpenDataFork(fsRdWrPerm);
		_preferencesFileisWritable = true;			
		preferencesHandle = _preferencesFile->ReadDataFork();
		_preferencesFile->CloseDataFork();
		
		parsePreferences(preferencesHandle);
		::DisposeHandle(preferencesHandle);

	} catch (...) {
	
		try {
			dprintf("creating new preferences file\n");
			_preferencesFile->CreateNewDataFile(kApplicationCreator,'pref',smSystemScript);	
			_preferencesFileisWritable = true;	
					
		} catch (...) {
		
		}
	}
*/
}


CPreferences::~CPreferences()
{
}


void CPreferences::parsePreferences(Handle preferencesHandle)
{
	::HLock(preferencesHandle);
	long size = GetHandleSize(preferencesHandle);
	char *p = (char*) *preferencesHandle;
	char *e = p + size;
	int lineno = 1;
	string delimiters =  " ,\t";
	
	while (p < e) {
		string line = nextLine(p,e);
		//dprintf("%d: %s\n", lineno++, line.c_str());
		
		CTokenizer tokenizer(line, delimiters);
		string token;
		
		token = tokenizer.nextToken();
		if (token.length()) {
			if (lowerString(token) == "bind") {
				string keyName = tokenizer.nextToken();
				string keyCommand = tokenizer.nextToken();
				//dprintf(" keyName %s keyCommand %s\n", keyName.c_str(), keyCommand.c_str());
				_keyBindings[keyName] = keyCommand;
			} else if (lowerString(token) == "set") {
				string setting = tokenizer.nextToken();
				string value = tokenizer.nextToken();
				_settings[setting] = value;
			} else if (lowerString(token) == "file") {
				string value = tokenizer.nextToken();
				if (fileExists(value))
					_recentFiles.push_back(value);
			}
		}
	}
	
	::HUnlock(preferencesHandle);
}

void CPreferences::writePreferences()
{
	if (!_preferencesFileisWritable)
		return;
		
	dprintf("writing preferences...\n");
	string preferences = "// Generated by PakRat, modify at your own risk.\n";
	
	// write out all the key bindings
	pref_iterator e;
	e = _keyBindings.begin();
	while (e != _keyBindings.end()) {
		preferences += "bind " + e->first + " " + quotedString(e->second) + "\n";
		e++;
	}	

	// write out all the settings
	e = _settings.begin();
	while (e != _settings.end()) {
		preferences += "set " + e->first + " " + quotedString(e->second) + "\n";
		e++;
	}	
		
	// write out all the recent files
	recent_type_iterator e1 = _recentFiles.begin();
	while (e1 != _recentFiles.end()) {
		string s = *e1;
		preferences += "file " + quotedString(s) + "\n";
		e1++;
	}	
		
	try {
		_preferencesFile->OpenDataFork(fsWrPerm);
		_preferencesFile->WriteDataFork(preferences.c_str(), preferences.length());
		_preferencesFile->CloseDataFork();

	} catch (...) {
	
		// oh well
		dprintf("exception generated writing preferences!\n");
	}
}

Boolean CPreferences::booleanForKey(string key)
{
	string value  = lowerString(_settings[key]);
	if (value == "1" || value == "yes" || value == "true")
		return true;
	return false;
}

void CPreferences::setBooleanForKey(Boolean b, string key)
{
	if (b)
		_settings[key] = "1";
	else
		_settings[key] = "0";
		
	writePreferences();
}

void CPreferences::addRecentFile(string path)
{	
	int max = intValue(valueForKey("recentFiles"));
	_recentFiles.remove(path);
	while (_recentFiles.size() > max)
		_recentFiles.pop_back();
	_recentFiles.push_front(path);
	writePreferences();
}

string CPreferences::recentFileAtIndex(SInt16 index)
{	 
	if (index > _recentFiles.size())
		return "";
		
	printf("recentFileAtIndex(SInt16 index) %d\n", index);
	index--;
	recent_type::iterator e = _recentFiles.begin();
	while(index--) e++;
	return *e;
	/*
	string file;
	file = _recentFiles[index-1];
	return file;
	*/
}

string CPreferences::valueForKey(string key)
{
	return _settings[key];
}

void CPreferences::setValueForKey(string value, string key)
{
	_settings[key] = value;
	writePreferences();
}

string CPreferences::commandForKeyEvent(const EventRecord	&inKeyEvent)
{
	Boolean	keyHandled = false;
	UInt8	theChar = (UInt16) (inKeyEvent.message & charCodeMask);
	UInt16	theKey = (UInt16) (inKeyEvent.message & keyCodeMask);
	
	//dprintf("CPreferences::commandForKeyEvent theChar %c theChar %d theKey 0x%x\n", theChar, theChar, theKey);
		
	switch (theKey) {
	
		case 0x3000: return _keyBindings["TAB"];
		case 0x2400: return _keyBindings["ENTER"];
		case 0x3500: return _keyBindings["ESCAPE"];
		case 0x3100: return _keyBindings["SPACE"];
		case 0x3300: return _keyBindings["DEL"];
		case 0x7900: return _keyBindings["PGDN"];
		
		case 0x7e00: return _keyBindings["UPARROW"];
		case 0x7d00: return _keyBindings["DOWNARROW"];
		case 0x7b00: return _keyBindings["LEFTARROW"];
		case 0x7c00: return _keyBindings["RIGHTARROW"];
		
		case 0x7a00: return _keyBindings["F1"];
		case 0x7800: return _keyBindings["F2"];
		case 0x6300: return _keyBindings["F3"];
		case 0x7600: return _keyBindings["F4"];
		case 0x6000: return _keyBindings["F5"];
		case 0x6100: return _keyBindings["F6"];
		case 0x6200: return _keyBindings["F7"];
		case 0x6400: return _keyBindings["F8"];
		case 0x6500: return _keyBindings["F9"];
		case 0x6d00: return _keyBindings["F10"];
		case 0x6700: return _keyBindings["F11"];
		case 0x6F00: return _keyBindings["F12"];
		
		case 0x5900: return _keyBindings["KP_HOME"];
		case 0x5b00: return _keyBindings["KP_UPARROW"];
		case 0x5c00: return _keyBindings["KP_PGUP"];
		
		case 0x5600: return _keyBindings["KP_LEFTARROW"];
		case 0x5700: return _keyBindings["KP_5"];
		case 0x5800: return _keyBindings["KP_RIGHTARROW"];
		
		case 0x5400: return _keyBindings["KP_DOWNARROW"];
		case 0x4c00: return _keyBindings["KP_ENTER"];
		case 0x5200: return _keyBindings["KP_INS"];
		
		/*
		case 0x00: return _keyBindings["END"]; // my iMac doesn't have one of these!!
		case 0x00: return _keyBindings["ALT"];
		case 0x00: return _keyBindings["CTRL"];
		case 0x00: return _keyBindings["SHIFT"];
		case 0x00: return _keyBindings["PAUSE"];
		case 0x00: return _keyBindings["MOUSE1"];
		case 0x00: return _keyBindings["MOUSE2"];
		case 0x00: return _keyBindings["MOUSE3"];
		case 0x00: return _keyBindings["MWHEELDOWN"];
		case 0x00: return _keyBindings["MWHEELUP"];
		*/
	}

	// key code did not match, try the character
	char *s = "0";
	s[0] = theChar;
	string command = _keyBindings[s];
	if (command.length())
		return command;

	return "";
}



